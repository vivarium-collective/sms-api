import json
import logging
import random
import string
from pathlib import Path

from fastapi import HTTPException

from sms_api.common.handlers.simulators import upload_simulator
from sms_api.common.hpc.slurm_service import SlurmService
from sms_api.dependencies import get_database_service, get_simulation_service, get_ssh_session_service
from sms_api.simulation.database_service import DatabaseService
from sms_api.simulation.hpc_utils import get_correlation_id
from sms_api.simulation.models import (
    JobType,
    ParcaDataset,
    ParcaDatasetRequest,
    ParcaOptions,
    Simulation,
    SimulationRequest,
    SimulationRun,
    SimulatorVersion,
)
from sms_api.simulation.simulation_service import SimulationService

logger = logging.getLogger(__name__)

# Get repo root for absolute path references
REPO_DIR = Path(__file__).parent.parent.parent.parent.absolute()

# Directory for debug artifacts (gitignored)
DEBUG_ARTIFACTS_DIR = REPO_DIR / "artifacts"


def export_baseline_config(request: SimulationRequest) -> None:
    """Capture simulation config to disk for debugging/inspection.

    Writes the config to the artifacts/ directory at repo root.
    This directory is gitignored and used for debugging purposes only.
    """
    DEBUG_ARTIFACTS_DIR.mkdir(parents=True, exist_ok=True)
    config_path = DEBUG_ARTIFACTS_DIR / "baseline_config.json"
    with open(config_path, "w") as fp:
        json.dump(request.config.model_dump(), fp, indent=3)


async def run_workflow(
    request: SimulationRequest,
    simulation_service: SimulationService,
    database_service: DatabaseService,
) -> Simulation:
    """
    Parameterizes and executes a "full" e2e sms-api vEcoli workflow
    (simulator -> parca ref -> Simulation(parca -> variants -> simulation -> analyses)
    """
    export_baseline_config(request)

    # 1. upload simulator if needed
    if request.simulator_id is not None:
        simulator = await database_service.get_simulator(request.simulator_id)
    else:
        simulator = await upload_simulator(
            commit_hash=request.simulator.git_commit_hash,  # type: ignore[union-attr]
            git_branch=request.simulator.git_branch,  # type: ignore[union-attr]
            git_repo_url=request.simulator.git_repo_url,  # type: ignore[union-attr]
            database_service=database_service,
            simulation_service_slurm=simulation_service,
        )
    # 2. create parca ds reference for the simData that will be generated by this request
    # TODO: use config hash to check if exists first
    parca_config = request.config.parca_options.model_dump()
    parca_ds = await database_service.insert_parca_dataset(
        parca_dataset_request=ParcaDatasetRequest(simulator_version=simulator, parca_config=parca_config)  # type: ignore[arg-type]
    )
    request.parca_dataset_id = parca_ds.database_id

    # 3. run simulation (save to db and insert hpc run)
    simulation = await database_service.insert_simulation(sim_request=request)
    random_string_7_hex = "".join(random.choices(string.hexdigits, k=7))
    correlation_id = get_correlation_id(
        ecoli_simulation=simulation,
        random_string=random_string_7_hex,
        simulator=simulator,  # type: ignore[arg-type]
    )
    async with get_ssh_session_service().session() as ssh:
        slurmjob_id = await simulation_service.submit_ecoli_simulation_job(
            ecoli_simulation=simulation, database_service=database_service, correlation_id=correlation_id, ssh=ssh
        )
    _ = await database_service.insert_hpcrun(
        slurmjobid=slurmjob_id,
        job_type=JobType.SIMULATION,
        ref_id=simulation.database_id,
        correlation_id=correlation_id,
    )

    simulation.job_id = slurmjob_id
    return simulation


async def run_parca(
    simulator: SimulatorVersion,
    simulation_service_slurm: SimulationService | None = None,
    database_service: DatabaseService | None = None,
    parca_config: ParcaOptions | None = None,
) -> ParcaDataset:
    if not simulation_service_slurm:
        simulation_service_slurm = get_simulation_service()
    if simulation_service_slurm is None:
        logger.exception("Simulation service is not initialized")
        raise HTTPException(status_code=404, detail="Simulation service is not initialized")
    if not database_service:
        database_service = get_database_service()
    if database_service is None:
        logger.exception("Simulation database service is not initialized")
        raise HTTPException(status_code=404, detail="Simulation database service is not initialized")

    parca_dataset_request = ParcaDatasetRequest(
        simulator_version=simulator, parca_config=parca_config or ParcaOptions()
    )
    parca_dataset = await database_service.insert_parca_dataset(parca_dataset_request=parca_dataset_request)

    # Submit parca job
    async with get_ssh_session_service().session() as ssh:
        parca_slurmjobid = await simulation_service_slurm.submit_parca_job(parca_dataset=parca_dataset, ssh=ssh)
    _hpc_run = await database_service.insert_hpcrun(
        slurmjobid=parca_slurmjobid,
        job_type=JobType.PARCA,
        ref_id=parca_dataset.database_id,
        correlation_id="N/A",
    )

    return parca_dataset


async def get_parca_datasets(
    simulation_service_slurm: SimulationService | None = None,
    database_service: DatabaseService | None = None,
) -> list[ParcaDataset]:
    if not simulation_service_slurm:
        simulation_service_slurm = get_simulation_service()
    if simulation_service_slurm is None:
        logger.exception("Simulation service is not initialized")
        raise HTTPException(status_code=404, detail="Simulation service is not initialized")
    if not database_service:
        database_service = get_database_service()
    if database_service is None:
        logger.exception("Simulation database service is not initialized")
        raise HTTPException(status_code=404, detail="Simulation database service is not initialized")

    parca_datasets = await database_service.list_parca_datasets()
    return parca_datasets


async def get_simulation(db_service: DatabaseService, id: int) -> Simulation | None:
    return await db_service.get_simulation(simulation_id=id)


async def get_simulation_status(db_service: DatabaseService, id: int) -> SimulationRun:
    sim_record = await db_service.get_simulation(simulation_id=id)
    if sim_record is None:
        raise ValueError(f"Simulation with id {id} not found.")

    # Get the HpcRun record for this simulation to find the SLURM job ID
    hpc_run = await db_service.get_hpcrun_by_ref(ref_id=id, job_type=JobType.SIMULATION)
    if hpc_run is None:
        raise RuntimeError(f"No HPC run found for simulation {id}")
    if hpc_run.slurmjobid is None:
        raise RuntimeError(f"Simulation {id} not yet dispatched to SLURM")

    slurm_service = SlurmService()
    async with get_ssh_session_service().session() as ssh:
        # First try squeue (for running/pending jobs)
        slurm_jobs = await slurm_service.get_job_status_squeue(ssh, job_ids=[hpc_run.slurmjobid])
        if not slurm_jobs:
            # Job not in queue, check sacct for completed jobs
            slurm_jobs = await slurm_service.get_job_status_sacct(ssh, job_ids=[hpc_run.slurmjobid])

    if not slurm_jobs:
        # Job was just submitted and may not have propagated to SLURM yet
        # Return UNKNOWN since we can't confirm the actual state
        from sms_api.common.models import JobStatus

        logger.warning(f"SLURM job {hpc_run.slurmjobid} not yet visible in squeue/sacct, returning UNKNOWN")
        return SimulationRun(id=int(id), status=JobStatus.UNKNOWN)

    slurm_job = slurm_jobs[0]
    return SimulationRun(id=int(id), status=slurm_job.get_job_status())


async def list_simulations(db_service: DatabaseService) -> list[Simulation]:
    return await db_service.list_simulations()


# async def get_simulation_log(db_service: DatabaseService, id: int) -> fastapi.Response:
#     stdout = await _get_slurm_log(db_service, id)
#     _, _, after = stdout.partition("N E X T F L O W")
#     result = "N E X T F L O W" + after
#     return fastapi.Response(content=result, media_type="text/plain")
#
#
# async def get_simulation_log_detailed(db_service: DatabaseService, id: int) -> str:
#     return await _get_slurm_log(db_service=db_service, db_id=id)
#
#
# async def _get_slurm_log(remote_log_path: HPCFilePath) -> str | None:
#     async with get_ssh_session_service().session() as ssh:
#         returncode, stdout, stderr = await ssh.run_command(f"cat {remote_log_path!s}.out")
#     return stdout
